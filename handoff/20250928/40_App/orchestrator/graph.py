import os, argparse, time, uuid, hashlib
from typing import Optional
from dotenv import load_dotenv
from tools.github_api import get_repo, create_branch, commit_file, open_pr, get_pr_checks, close_pr, delete_branch
from redis_queue.worker import enqueue
from memory.pgvector_store import save_text, recall_top
from llm.faq_generator import generate_faq_content
from utils.rate_limit import check_pr_rate_limit
from governance.cost_tracker import get_cost_tracker, CostBudgetExceeded
from governance.reputation_engine import get_reputation_engine

def planner(goal:str):
    steps = ["analyze", "patch", "open PR", "check CI"]
    save_text("goal", goal)
    return steps

def execute(goal:str, repo_full: str, trace_id: Optional[str] = None):
    if trace_id is None:
        trace_id = str(uuid.uuid4())
    
    cost_tracker = get_cost_tracker()
    reputation_engine = get_reputation_engine()
    agent_id = reputation_engine.get_or_create_agent('meta_agent')
    
    try:
        cost_tracker.enforce_budget(trace_id, period='daily')
        cost_tracker.enforce_budget(trace_id, period='hourly')
    except CostBudgetExceeded as e:
        print(f"[Cost] Budget exceeded: {e}")
        if agent_id:
            reputation_engine.record_event(agent_id, 'cost_overrun', trace_id=trace_id, reason=str(e))
        return None, "budget_exceeded", trace_id
    
    allowed, count = check_pr_rate_limit(trace_id, max_per_hour=10, redis_url=os.getenv("REDIS_URL"))
    if not allowed:
        print(f"[Rate Limit] BLOCKED - Already created {count} PRs this hour")
        return None, "rate_limited", trace_id
    
    repo = get_repo()
    timestamp = int(time.time())
    branch = create_branch(repo, base="main", new_branch=f"orchestrator/{timestamp}-faq-update")
    
    try:
        faq_content = generate_faq_content(goal, trace_id, repo_full)
        print(f"[GPT-4] Generated FAQ content ({len(faq_content)} chars)")
        
        estimated_tokens = len(faq_content) // 4  # Rough estimate: 4 chars per token
        estimated_cost = cost_tracker.estimate_cost(estimated_tokens, model='gpt-4')
        cost_tracker.track_usage(trace_id, estimated_tokens, estimated_cost, model='gpt-4', operation='faq_generation')
        
    except Exception as e:
        print(f"[GPT-4] Failed to generate content: {e}, using fallback")
        # Fallback is handled inside generate_faq_content
        faq_content = generate_faq_content(goal, trace_id, repo_full)
    
    commit_file(repo, branch, "docs/FAQ.md", faq_content, f"docs: add FAQ.md (trace-id: {trace_id})")
    
    is_test_mode = os.getenv("ORCHESTRATOR_TEST_MODE", "false").lower() == "true"
    
    pr_body = f"""## Automated FAQ Update

**Task:** {goal}
**Trace ID:** `{trace_id}`
**Branch:** `{branch}`
**Test Mode:** {"✅ Yes (Draft PR)" if is_test_mode else "❌ No (Production)"}

This PR was automatically generated by the MorningAI Orchestrator.

[Link to Devin run](https://app.devin.ai/sessions/9142c8e8a3de4754a7ba8e8c06a751ed)
Requested by: @RC918

---

**Note:** {"This is a test PR and will be automatically cleaned up after CI validation." if is_test_mode else "This is a production PR for review and merge."}
"""
    
    labels = ["automated-test", "orchestrator"] if is_test_mode else ["orchestrator"]
    
    pr_url, pr_num = open_pr(
        repo, 
        branch, 
        f"docs: Update FAQ (trace-id: {trace_id[:8]})", 
        body=pr_body,
        draft=is_test_mode,
        labels=labels
    )
    print(f"[PR] {pr_url} (trace-id: {trace_id})")
    
    if not is_test_mode:
        try:
            import subprocess
            subprocess.run([
                "gh", "pr", "merge", str(pr_num),
                "--auto", "--squash",
                "--repo", repo_full
            ], check=False)
            print(f"[GitHub] Auto-merge enabled for production PR")
        except Exception as e:
            print(f"[GitHub] Could not enable auto-merge: {e}")
    else:
        print(f"[Test Mode] Skipping auto-merge for draft PR")
    
    state, checks = get_pr_checks(repo, pr_num)
    print(f"[CI] state={state} checks={checks}")
    
    if agent_id and state == "success":
        reputation_engine.record_event(agent_id, 'test_passed', trace_id=trace_id, reason='CI checks passed')
    elif agent_id and state in ["failure", "error"]:
        reputation_engine.record_event(agent_id, 'test_failed', trace_id=trace_id, reason=f'CI checks failed: {state}')
    
    budget_status = cost_tracker.get_budget_status(trace_id, period='daily')
    print(f"[Cost] Daily budget: {budget_status['usage']['usd']:.2f}/${budget_status['limits']['usd']:.2f} USD ({budget_status['percentages']['usd']:.1f}%)")
    
    if is_test_mode:
        print(f"[Test Mode] PR #{pr_num} created as draft for testing")
        print(f"[Test Mode] Auto-cleanup enabled after CI validation")
        
        if state in ["success", "failure", "error"]:
            print(f"[Test Mode] CI completed with state: {state}")
            print(f"[Test Mode] Cleaning up test PR...")
            
            cleanup_comment = f"""## Automated Test Cleanup

This PR was created in test mode and has completed CI validation.

**CI State:** {state}
**Trace ID:** {trace_id}

Closing this PR and cleaning up the branch.

✅ Orchestrator system validation complete!
"""
            
            if close_pr(repo, pr_num, cleanup_comment):
                print(f"[Test Mode] PR #{pr_num} closed")
                
                if delete_branch(repo, branch):
                    print(f"[Test Mode] Branch {branch} deleted")
            else:
                print(f"[Test Mode] Failed to cleanup, manual intervention required")
    
    return pr_url, state, trace_id

def main(goal:str, repo:str):
    trace_id = str(uuid.uuid4())
    print(f"[Trace] Starting task with trace-id: {trace_id}")
    
    steps = planner(goal)
    print("[Planner] steps:", steps)
    
    idempotency_key = hashlib.md5(goal.encode()).hexdigest()
    
    try:
        job_ids = enqueue(steps, idempotency_key=idempotency_key)
        print("[Queue] enqueued jobs:", job_ids)
    except Exception as e:
        print(f"[Queue] Redis unavailable, continuing in demo mode: {e}")
        job_ids = [f"demo-job-{i}" for i in range(len(steps))]
    
    try:
        pr_url, state, trace_id = execute(goal, repo, trace_id=trace_id)
        print("[Result]", pr_url, state, f"trace-id: {trace_id}")
    except Exception as e:
        print(f"[GitHub] API unavailable, continuing in demo mode: {e}")
        pr_url, state = "demo-pr-url", "demo"
    
    try:
        mem = recall_top("recent")
        print("[Memory] recent items:", len(mem))
    except Exception as e:
        print(f"[Memory] Supabase unavailable, continuing in demo mode: {e}")
        mem = []

if __name__ == "__main__":
    load_dotenv()
    ap = argparse.ArgumentParser()
    ap.add_argument("--goal", required=True)
    ap.add_argument("--repo", default=os.getenv("GITHUB_REPO","RC918/morningai"))
    args = ap.parse_args()
    main(args.goal, args.repo)
